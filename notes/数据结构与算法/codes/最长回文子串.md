### Manacher算法

```
public String longestPalindrome(String s) {
        String manacherString = getManacherString(s);
        int[] p = new int[manacherString.length()];

        int maxIndex = 0;
        int max = 0;

        int c = -1;
        int r = -1;

        // 以Manacher字符串的每个字符为中心进行扩展
        for (int i = 0; i < p.length; i++) {
            // 回文半径数组，其与回文长度L的关系为L=2*p[i]-1
            p[i] = 1;

            // 回文子串左边界，其与回文半径的关系为left=i-p[i]+1
            int left = i - 1;
            // 回文子串右边界，其与回文半径的关系为right=i+p[i]-1
            int right = i + 1;

            // 如果回文中心字符不在回文最右边界的右侧，则可以利用半径数组使回文左右边界跳跃扩展，但右边界最大扩展到r
            // left和right分别指向回文子串左右边界的下一个字符
            if (i <= r) {
                if (i+ p[2*c-i] - 1 < r) {
                    left = i - p[2*c-i];
                    right = i + p[2*c-i];
                    p[i] = p[2*c-i];
                } else {
                    left = 2*i-r-1;
                    right = r+1;
                    p[i] = r-i+1;
                }
            }

            // 对回文子串左右边界进行扩展
            while (left >= 0 && right < p.length) {
                if (manacherString.charAt(left) == manacherString.charAt(right)) {
                    p[i] += 1;
                    left--;
                    right++;
                } else {
                    break;
                }
            }
            // 更新回文半径和回文中心
            if (right - 1 > r) {
                r = right - 1;
                c = i;
            }
            // 更新最长回文子串中心索引
            if (p[i] > max) {
                maxIndex = i;
                max = p[i];
            }
        }

        return manacherString.substring(maxIndex - p[maxIndex] + 1, maxIndex + p[maxIndex] - 1).replace("#", "");
    }

    private String getManacherString(String s) {
        StringBuffer sb = new StringBuffer();
        sb.append("#");
        for (int i = 0; i < s.length(); i++) {
            sb.append(s.charAt(i));
            sb.append("#");
        }
        return sb.toString();
    }